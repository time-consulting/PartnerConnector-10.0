
The problem causing the flickering and reloading in Incognito Mode is a classic Redirect Race Condition within your client-side authentication logic, specifically inside the PrivateRoute component in client/src/App.tsx.

The core reason is that your PrivateRoute renders a temporary state after the authentication check is complete but before the wouter router has finished redirecting the application to the new URL (/login).

Here is the precise cause and the solution to eliminate the flicker and stabilize your routing.

1. The Core Problem: Delayed Redirect
The issue lies in how the PrivateRoute handles the unauthenticated state:

A. The Flicker Cause (Redundant Render)
In client/src/App.tsx, the PrivateRoute has redundant checks that cause the flicker:

TypeScript
// Inside PrivateRoute in App.tsx

// 1. Loading Check (Renders Loading)
if (isLoading) { /* ... return Loading... */ }

// 2. Unauthenticated Check (Renders Redirecting message) <-- THIS IS THE PROBLEM
if (!isAuthenticated) {
    return (
      <div className="min-h-screen flex items-center justify-center">
        <div className="text-lg">Redirecting to login...</div> 
      </div>
    );
}

// 3. Effect (Triggers Redirect)
useEffect(() => {
    if (!isLoading && !isAuthenticated) {
      setLocation('/login'); // ðŸ›‘ The redirect happens HERE.
    }
    // ... onboarding logic ...
}, [isAuthenticated, isLoading, user, bypassOnboarding, setLocation]);
The component renders the content in step (2) (the "Redirecting to login..." message) for a split second before the useEffect in step (3) updates the route via setLocation('/login'). This renders a temporary page before the router takes over, causing the flicker.

B. The Reload Cause (Wouter Behavior)
Since protected routes often include components that rely on the authenticated user data (user), if the component renders before the redirect is fully processed, it might cause a component error or trigger a router-level safety mechanism that forces a reload to clear the invalid state.

2. The Solution: Optimize PrivateRoute Logic
The fix is to remove the explicit rendering of the "Redirecting to login..." message and rely solely on the isLoading state to delay rendering the protected children.

Action 1: Simplify the PrivateRoute Component
Modify client/src/App.tsx by removing the redundant unauthenticated render block.

TypeScript
// File: client/src/App.tsx

function PrivateRoute({ children, bypassOnboarding = false }: { children: React.ReactNode; bypassOnboarding?: boolean }) {
  const { isAuthenticated, isLoading, user } = useAuth();
  const [location, setLocation] = useLocation();
  
  useEffect(() => {
    // If loading is finished AND user is not authenticated, redirect.
    if (!isLoading && !isAuthenticated) {
      setLocation('/login');
    } 
    // If loading is finished AND authenticated AND onboarding is incomplete, redirect to onboarding.
    else if (!isLoading && isAuthenticated && !bypassOnboarding && user && !user.hasCompletedOnboarding && location !== '/onboarding') {
      setLocation('/onboarding');
    }
  }, [isAuthenticated, isLoading, user, bypassOnboarding, setLocation]);

  // ðŸ›‘ 1. If loading, show loading fallback screen (Crucial to prevent flicker)
  if (isLoading) {
    // Use the comprehensive LoadingFallback component from App.tsx instead of a simple div
    return <LoadingFallback />;
  }

  // ðŸ›‘ 2. If NOT authenticated, but loading is finished, return null. 
  // The useEffect above has already triggered the redirect, so we just wait for Wouter to process it.
  if (!isAuthenticated) {
    return null; // Stop rendering here to prevent flicker
  }

  // 3. If onboarding redirect was triggered in the useEffect, also return null while waiting.
  if (!bypassOnboarding && user && !user.hasCompletedOnboarding && location !== '/onboarding') {
    return null; // Redirect is pending
  }
  
  // 4. Everything is authenticated and authorized, render content.
  return <>{children}</>;
}
By changing the unauthenticated check to return null, you prevent the component from attempting to render anything on the page, relying entirely on the useEffect to safely navigate the router, eliminating the visual flicker.